import kotlinx.serialization.json.JsonObject;

CREATE TABLE element (
    id TEXT NOT NULL PRIMARY KEY,
    lat REAL NOT NULL,
    lon REAL NOT NULL,
    icon_id TEXT NOT NULL,
    osm_json TEXT AS JsonObject NOT NULL,
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL,
    deleted_at TEXT NOT NULL
);

CREATE INDEX idx_element_lat_lon ON element (lat, lon);

CREATE VIEW view_element_map_pin AS
SELECT
    id,
    lat,
    lon,
    icon_id
FROM element
WHERE deleted_at = '';

CREATE VIEW view_element_map_cluster AS
SELECT
    count(*),
    id,
    lat,
    lon,
    icon_id
FROM element
WHERE deleted_at = '';

insertOrReplace:
INSERT OR REPLACE
INTO element (id, lat, lon, icon_id, osm_json, created_at, updated_at, deleted_at)
VALUES ?;

selectAll:
SELECT *
FROM element;

selectAllElementsAsMapPins:
SELECT *
FROM view_element_map_pin;

selectById:
SELECT *
FROM element
WHERE id = ?;

selectBySearchString:
SELECT *
FROM element
WHERE deleted_at = '' AND (UPPER(osm_json) LIKE '%' || UPPER(:searchString) || '%')
LIMIT 100;

selectElementsAsPins:
SELECT
    count(*),
    e.id,
    avg(e.lat) AS lat,
    avg(e.lon) AS lon,
    e.icon_id
FROM element e
GROUP BY round(lat / :step) * :step, round(lon / :step) * :step
ORDER BY e.lat DESC;

selectElementsAsPinsByBoundingBox:
SELECT *
FROM view_element_map_pin
WHERE lat > :minLat
AND lat < :maxLat
AND lon > :minLon
AND lon < :maxLon
ORDER BY lat DESC;

selectElementIdIconAndTags:
SELECT
    id,
    icon_id,
    json_extract(osm_json, '$.tags') AS tags
FROM element
WHERE
deleted_at = ''
AND lat > :minLat
AND lat < :maxLat
AND lon > :minLon
AND lon < :maxLon;

selectCount:
SELECT COUNT(*)
FROM element;

selectMaxUpdatedAt:
SELECT max(updated_at)
FROM element;